#ifndef SRC_CONFAB_ASSET_HPP_
#define SRC_CONFAB_ASSET_HPP_

#include "Database.hpp"
#include "SizedPointer.hpp"

// Flatbuffer includes generated by calling flatc on the Flatbuffer schema (.fbs) files.
#include "schemas/FlatAsset_generated.h"

#include <memory>
#include <optional>
#include <string>

namespace Confab {

/*! Represents the metadata associated with a Confab digital asset.
 *
 * Designed for read-only zero-copy access to the underlying serial FlatAsset buffer, or for construction of a new
 * FlatAsset buffer by adding data using the various set attribute methods.
 */
class Asset {
public:
    /*! Describes the type of the Asset.
     *
     * Keep these values the same as in the FlatAsset schema.
     */
    enum Type : uint32_t {
        kInvalid = 1,
        kSnippet = 2,
        kImage = 3,
        kYAML = 4,
        kSample = 5
    };

    /*! Utility to convert a string into the equivalent Asset::Type enumeration.
     *
     * \param assetType A string describing the asset type
     * \return The equivalent enumerated type, kInvalid on error.
     */
    static Type typeStringToEnum(const std::string& assetType);

    /*! Converts a 64-bit binary key into a human-readable hexadecimal string.
     *
     * \param key A binary key.
     * \return A hexadecimal string of key.
     */
    static std::string keyToString(uint64_t key);

    /*! Converts a 64-bit hexadecimal string into a binary key.
     *
     * \param keyString A key in hexadecimal string form.
     * \return The binary value of that string, or zero on error.
     */
    static uint64_t stringToKey(const std::string& keyString);

    /*! Constructs a new empty Asset.
     *
     * \param type The type of asset to make.
     */
    Asset(Type type);

    /*! Constructs a new Asset based on a backing FlatAsset store.
     *
     * \param Asset The serialized FlatAsset object.
     * \param key The key associated with this asset. If the serialized asset in data has a key the serialized key will
     *            override this value and it will be ignored. But if the key is absent from those data it can be
     *            provided here.
     * \return An Asset object created by copying the FlatAsset inside of record.
     */
    explicit Asset(const Data::FlatAsset* Asset, uint64_t key = 0);

    /*! Serialize and return a pointer to the flattened Asset.
     *
     * \param builder A FlatBufferBuilder object to serialize the Asset in to.
     */
    void flatten(flatbuffers::FlatBufferBuilder& builder);

    /*! The type of this Asset.
     *
     * \return The type of this Asset.
     */
    Type type() const { return m_type; }

    /*! Set a value for the key attribute, which is zero otherwise.
     *
     * \param key The key value.
     */
    void setKey(uint64_t key) { m_key = key; }

    /*! Asset unique identifier, must be non-zero.
     *
     * \return The key of this Asset, or zero if not set.
     */
    uint64_t key() const { return m_key; }

    /*! Sets an optional human-readable name for the Asset.
     *
     * \param name The name value.
     */
    void setName(const std::string& name) { m_name = name; }

    /*! Human-readable name of the Asset, null-terminated string if present.
     *
     * \return A pointer to a human-readable name.
     */
    std::string name() const { return m_name; }

    /*! Add the file extension string.
     *
     * \note The . is normally not stored.
     *
     * \param fileExtension The extension of the file, e.g. "yaml", "png", "wav".
     */
    void setFileExtension(const std::string& fileExtension) { m_fileExtension = fileExtension; }

    /*! Extension of Asset file, e.g. ".yaml", ".scd", ".png". Null-terminated string if present.
     *
     * \return A string with a file extension, not including the period.
     */
    const std::string& fileExtension() const { return m_fileExtension; }

    /*! Sets a key for an Author entry.
     *
     * \param authorKey The key for the author data entry.
     */
    void setAuthor(uint64_t authorKey) { m_author = authorKey; }

    /*! Key of a YAML Asset describing a person who made this content, if present.
     *
     * \return Asset key for the Author entity, or 0 if not present.
     */
    uint64_t author() const { return m_author; }

    /*! Provides an optional key that represents a newer version of this Asset.
     *
     * \param deprecatedByKey The key to the Asset that deprecates this one.
     */
    void setDeprecatedBy(uint64_t deprecatedByKey) { m_deprecatedBy = deprecatedByKey; }

    /*! Key of a newer Asset to use in place of this one, if present.
     *
     * \return The key for an Asset that deprecates this one.
     */
    uint64_t deprecatedBy() const { return m_deprecatedBy; }

    /*! Sets the key for the older Asset this one replaces.
     *
     * \param deprecatesKey The key that this asset replaces.
     */
    void setDeprecates(uint64_t deprecatesKey) { m_deprecates = deprecatesKey; }

    /*! Key of an older Asset this Asset replaces, if present.
     *
     * \return Asset key deprecated by this one.
     */
    uint64_t deprecates() const { return m_deprecates; }

    /*! Reserves space in the backing store for an inline buffer, returning the pointer to that space for writing.
     *
     * \param size How many bytes to reserve. Should be less than or equal to kSingleChunkDataSize.
     * \return A non-owning pointer to the area reserved.
     */
    uint8_t* setInlineData(size_t size) {
        m_inlineData.reset(new uint8_t[size]);
        m_inlineDataSize = size;
        return m_inlineData.get();
    }

    /*! Attached Asset data, if present.
     *
     * Some Assets are small enough it makes sense to serialize the data directly with the Asset metadata. If so this
     * will point to a buffer of inlineDataSize() containing the Asset data.
     *
     * \return A pointer to the inline data, or nullptr if not present.
     */
    const uint8_t* inlineData() const { return m_inlineData.get(); }

    /*! Size of Asset data, if present.
     *
     * \return The size of the inline data pointed to by inlineData().
     * \sa inlineData()
     */
    size_t inlineDataSize() const { return m_inlineDataSize; }

    /*! Sets a UNIX epoch after which this Asset should be re-checked for validity or deleted.
     *
     * \param expiresOnEpoch The UNIX epoch to check this Asset on.
     */
    void setExpiresOn(uint64_t expiresOnEpoch) { m_expiresOn = expiresOnEpoch; }

    /*! Specifies a UNIX epoch after which this Asset should be re-checked for validity or deleted.
     *
     * For cached Assets, or Assets likely to be deprecated, can store a timeout here.
     *
     * \return A UNIX epoch for when this Asset should be refreshed, or 0 if not present.
     */
    uint64_t expiresOn() const { return m_expiresOn; }

    /*! Adds a salt value to the Asset.
     *
     * \param salt The salt value to add. It will be used as the starting state in hash computations.
     */
    void setSalt(uint64_t salt) { m_salt = salt; }

    /*! Provides an initial state for the hashing function, to reduce the chance of hash collision on small data sizes.
     *
     * \return A salt value.
     */
    uint64_t salt() const { return m_salt; }

    /// @cond UNDOCUMENTED
    Asset() = delete;
    Asset(const Asset& asset) = delete;
    Asset& operator=(const Asset& asset) = delete;
    ~Asset() = default;
    /// @endcond UNDOCUMENTED

private:
    Type m_type;
    uint64_t m_key;
    std::string m_name;
    std::string m_fileExtension;
    uint64_t m_author;
    uint64_t m_deprecatedBy;
    uint64_t m_deprecates;
    std::unique_ptr<uint8_t[]> m_inlineData;
    size_t m_inlineDataSize;
    uint64_t m_expiresOn;
    uint64_t m_salt;
};

}  // namespace Confab

#endif  // SRC_CONFAB_ASSET_HPP_

