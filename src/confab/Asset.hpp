#ifndef SRC_CONFAB_ASSET_HPP_
#define SRC_CONFAB_ASSET_HPP_

#include "Database.hpp"
#include "SizedPointer.hpp"

// Flatbuffer includes generated by calling flatc on the Flatbuffer schema (.fbs) files.
#include "schemas/FlatAsset_generated.h"

#include <memory>
#include <optional>
#include <string>
#include <vector>

namespace Confab {

/*! Represents the metadata associated with a Confab digital asset.
 *
 * Designed for read-only zero-copy access to the underlying serial FlatAsset buffer, or for construction of a new
 * FlatAsset buffer by adding data using the various set attribute methods.
 */
class Asset {
public:
    /*! Describes the type of the Asset.
     *
     * Keep these values the same as in the FlatAsset schema.
     */
    enum Type : uint32_t {
        kInvalid = 1,
        kSnippet = 2,
        kImage = 3,
        kYAML = 4,
        kSample = 5
    };

    /*! Utility to convert a string into the equivalent Asset::Type enumeration.
     *
     * \param assetType A string describing the asset type
     * \return The equivalent enumerated type, kInvalid on error.
     */
    static Type typeStringToEnum(const std::string& assetType);

    /*! Utility to convert an Asset::type enumeration back into a descriptive string.
     *
     * \param type The Asset enumerated type.
     * \return The string of that type, "invalid" on error.
     */
    static std::string enumToTypeString(Asset::Type type);

    /*! Converts a 64-bit binary key into a human-readable hexadecimal string.
     *
     * \param key A binary key.
     * \return A hexadecimal string of key.
     */
    static std::string keyToString(uint64_t key);

    /*! Converts a 64-bit hexadecimal string into a binary key.
     *
     * \param keyString A key in hexadecimal string form.
     * \return The binary value of that string, or zero on error.
     */
    static uint64_t stringToKey(const std::string& keyString);

    /*! Constructs a new empty Asset.
     *
     * \param type The type of asset to make.
     */
    Asset(Type type);

    /*! Constructs a new Asset based on a backing FlatAsset store.
     *
     * \param Asset The serialized FlatAsset object.
     * \return An Asset object created by copying the FlatAsset inside of record.
     */
    explicit Asset(const Data::FlatAsset* Asset);

    /*! Serialize and return a pointer to the flattened Asset.
     *
     * \param builder A FlatBufferBuilder object to serialize the Asset in to.
     * \param inlineData An optional buffer of data to serialize along with the Asset. Assumed to be of size of the
     *                   already-set size parameter. Will override any inlineData already copied in to this Asset.
     *                   Added here to allow saving an additional copy of the data into the Asset before serializing.
     */
    void flatten(flatbuffers::FlatBufferBuilder& builder, const uint8_t* inlineData = nullptr);

    /*! The type of this Asset.
     *
     * \return The type of this Asset.
     */
    Type type() const { return m_type; }

    /*! Set a value for the key attribute, which is zero otherwise.
     *
     * \param key The key value.
     */
    void setKey(uint64_t key) { m_key = key; }

    /*! Asset unique identifier, must be non-zero.
     *
     * \return The key of this Asset, or zero if not set.
     */
    uint64_t key() const { return m_key; }

    /*! Sets an optional human-readable name for the Asset.
     *
     * \param name The name value.
     */
    void setName(const std::string& name) { m_name = name; }

    /*! Human-readable name of the Asset, null-terminated string if present.
     *
     * \return A pointer to a human-readable name.
     */
    std::string name() const { return m_name; }

    /*! Add the file extension string.
     *
     * \note The . is normally included.
     *
     * \param fileExtension The extension of the file, e.g. ".yaml", ".png", ".wav".
     */
    void setFileExtension(const std::string& fileExtension) { m_fileExtension = fileExtension; }

    /*! Extension of Asset file, e.g. ".yaml", ".scd", ".png". Null-terminated string if present.
     *
     * \return A string with a file extension, not including the period.
     */
    const std::string& fileExtension() const { return m_fileExtension; }

    /*! Sets a key for an Author entry.
     *
     * \param authorKey The key for the author data entry.
     */
    void setAuthor(uint64_t authorKey) { m_author = authorKey; }

    /*! Key of a YAML Asset describing a person who made this content, if present.
     *
     * \return Asset key for the Author entity, or 0 if not present.
     */
    uint64_t author() const { return m_author; }

    /*! Provides an optional key that represents a newer version of this Asset.
     *
     * \param deprecatedByKey The key to the Asset that deprecates this one.
     */
    void setDeprecatedBy(uint64_t deprecatedByKey) { m_deprecatedBy = deprecatedByKey; }

    /*! Key of a newer Asset to use in place of this one, if present.
     *
     * \return The key for an Asset that deprecates this one.
     */
    uint64_t deprecatedBy() const { return m_deprecatedBy; }

    /*! Sets the key for the older Asset this one replaces.
     *
     * \param deprecatesKey The key that this asset replaces.
     */
    void setDeprecates(uint64_t deprecatesKey) { m_deprecates = deprecatesKey; }

    /*! Key of an older Asset this Asset replaces, if present.
     *
     * \return Asset key deprecated by this one.
     */
    uint64_t deprecates() const { return m_deprecates; }

    /*! Sets the size in bytes of the data associated with this Asset.
     *
     * \param size The size in bytes of the Asset.
     */
    void setSize(uint64_t size) { m_size = size; }

    /*! The size in bytes of the Asset.
     *
     * \return Size in bytes of the Asset.
     */
    uint64_t size() const { return m_size; }

    /*! The number of AssetData chunks associated with this Asset. If inlineData is present, this should be zero.
     *
     * \param chunks The number of chunks to store separately.
     */
    void setChunks(uint64_t chunks) { m_chunks = chunks; }

    /*! The number of AssetData chunks stored for this Asset.
     *
     * \return The number of chunks to expect stored with this Asset.
     */
    uint64_t chunks() const { return m_chunks; }

    /*! Adds a salt value to the Asset.
     *
     * \param salt The salt value to add. It will be used as the starting state in hash computations.
     */
    void setSalt(uint64_t salt) { m_salt = salt; }

    /*! Provides an initial state for the hashing function, to reduce the chance of hash collision on small data sizes.
     *  Only nonzero when inlineData is present.
     *
     * \return A salt value.
     */
    uint64_t salt() const { return m_salt; }

    /*! Returns the ids of the lists this Asset is included in.
     *
     * \return A vector of list ids.
     */
    const std::vector<uint64_t>& lists() const { return m_lists; }

    /*! Adds a list id to the list of lists, meaning this Asset will be automatically added to that list on storage.
     *
     * \param listKey The key of the list to add this Asset to.
     */
    void addToList(uint64_t listKey) { m_lists.push_back(listKey); }

    /*! Reserves space in the backing store for an inline buffer, returning the pointer to that space for writing.
     *
     * \param size How many bytes to reserve. Should be less than or equal to kSingleChunkDataSize.
     * \return A non-owning pointer to the area reserved.
     */
    uint8_t* setInlineData(size_t size) {
        m_inlineData.reset(new uint8_t[size]);
        m_size = size;
        return m_inlineData.get();
    }

    /*! Attached Asset data, if present.
     *
     * Some Assets are small enough it makes sense to serialize the data directly with the Asset metadata. If so this
     * will point to a buffer of inlineDataSize() containing the Asset data.
     *
     * \return A pointer to the inline data, or nullptr if not present.
     */
    const uint8_t* inlineData() const { return m_inlineData.get(); }

    /// @cond UNDOCUMENTED
    Asset() = delete;
    Asset(const Asset& asset) = delete;
    Asset& operator=(const Asset& asset) = delete;
    ~Asset() = default;
    /// @endcond UNDOCUMENTED

private:
    Type m_type;
    uint64_t m_key;
    std::string m_name;
    std::string m_fileExtension;
    uint64_t m_author;
    uint64_t m_deprecatedBy;
    uint64_t m_deprecates;
    uint64_t m_size;
    uint64_t m_chunks;
    std::vector<uint64_t> m_lists;

    uint64_t m_salt;
    std::unique_ptr<uint8_t[]> m_inlineData;
};

}  // namespace Confab

#endif  // SRC_CONFAB_ASSET_HPP_

