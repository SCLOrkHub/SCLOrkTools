title:: SCLOrkClock Time Synchronization Design
summary:: Documentation about how the time synchronization works.
categories:: Quarks>SCLOrkNet
related:: Classes/SCLOrkClock, Classes/SCLOrkTimeClient, Classes/SCLOrkTimeServer

In this document we detail the algorithm used by the link::Classes/SCLOrkTimeClient:: and link::Classes/SCLOrkTimeServer:: objects to synchronize the Supercollider clock time on the server across all the clients.

section:: Background

There are a variety of tools and technologies available for network clock synchronization. Of particular interest to here are the IP-based Network Time Protocol (link::https://en.wikipedia.org/wiki/Network_Time_Protocol##external link::), or NTP, and the lower-level Ethernet-based Precision Time Protocol (link::https://en.wikipedia.org/wiki/Precision_Time_Protocol##external link::), or PTP.

Both NTP and PTP are used to synhronize system clocks on different computers on the network to a high degree of precision. Both are mature protocols with stable, well-supported software implementations.

The problem is that, by default, SuperCollider does not seed its link::Classes/TempoClock:: beat values from the system clock. The TempoClock, like any implementation of link::Classes/Clock::, by default seeds its values from the link::Classes/Thread:: elapsedTime that it is started on. Threads by default seed their elapsedTime seconds counter from Main.elapsedTime. The value of Main.elapsedTime is computed as the amount of time that has elapsed during this instance of the interpreter.

What this means is that even if there is precision (sub-millisecond or better) synchronization between two computers, there is no guarantee at all that their SuperCollider Clocks will be synchronized, unless we can somehow guarantee that their sclang instances were started at precisely the same time. Given that during a SCLOrk performance an individual performer may need to restart their particuar interpreter instance, synchronized interpreter starting didn't seem like a great option.

I estimated our synchronization needs as probably in the tens of milliseconds, and so thought a naive implementation of the synchronization algorithm used in NTP in SuperCollider, designed to synchronize the Main.elapsedTime of the server, would likely be sufficient for our needs.

section:: Client Server Communication Protocol

subsection:: Server Endpoint

The link::Classes/SCLOrkTimeServer:: sets up a simple OSC UDP endpoint, by default at strong::/getTimeDiff::, which accepts messages in the following format from clients.

table::
## strong::int:: || elapsedTimeHigh32 || Client elapsed time high 32 bits.
## strong::int:: || elapsedTimeLow32  || Client elapsed time low 32 bits. (see note below).
## strong::string:: || clientPath || Return OSC path server should send reply to.
## strong::int:: || clientPort || Return UDP port the server should send reply to.
::

Upon request at this endpoint the server will compute the difference between its own
code::Main.elapsedTime:: and the value provided by the client, and return the result at the endpoint and port provided by the client.

note::
SuperCollider's internal implementation of floating point numbers uses double-precision 64-bit floats, but OSC standard protocol only supports sending of 32-bit floats. In order to avoid loss of precision both client and server serialize their time values into two 32-bit integers and send them in most significant to least significant word order.
::

subsection:: Client Endpoint

The link::Classes/SCLOrkTimeClient:: periodically sends a request to the server's endpoint, providing its own code::Main.elapsedTime::, and anticipates a response to that at the endpoint and port provided to the server, by default at strong::/setTimeDiff::, and data in the following format.

table::
## strong::int:: || timeDiffHigh32 || Server-computed time difference high 32 bits.
## strong::int:: || timeDiffLow32 || Server-computed time difference low 32 bits.
::

subsection:: Client-Computed Time Difference

Each time it requests it, the client receives a diff from its own code::Main.elapsedTime:: value and that of the server's. It is assumed that while the two elapased time values may not have any predictable realtionship to each other they are both measures of seconds elapsed, albiet by different clocks, and so therefore are both increasing monotonically at roughly the same rate.

When sending a request the client also notes the time when sent, and when the server responded, so can therefore measure the client -> server -> client emphasis::round trip time::. In a manner analagous to NTP, although less sophisticated, the client then computes a mean of the last several values of both the diff sent by the server and the round trip time, separately, and then computes the current emphasis::timeDiff:: as code::timeDiffMean - (roundTripTime / 2.0)::.

section:: Synchronized Time In SCLOrkClock Instances

The link::Classes/SCLOrkTimeClient:: provides a synchronized code::elapsedTime:: value in seconds but this only provides favorable initial conditions to provide an actual synchronized link::Classes/TempoClock::. This is the job of the link::Classes/SCLOrkClock:: object, which uses both the code::timeDiff:: value provided by the time client as well its own code::tempo:: attribute to compute a value for its own code::beats:: attribute.

By using the code::timeDiff:: value to compute code::beats:: within the clock the clocks work to provide syncronization of beat count across different computers. Because the beat count is synchronized this means that quantization is also synchronized, so one can expect that patterns will start playing on the correct downbeat. It's even possible to schedule events on these clocks for absolute beat counts, and if that time is in the future they should fire at the same time, even if on different computers.

Lastly, by decoupling the clock instances from the time client, developers are allowed to use multiple instances of the clock while sharing a single common link::Classes/SCLOrkTimeClient:: per computer.
