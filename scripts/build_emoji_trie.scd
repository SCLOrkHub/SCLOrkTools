(
// Add ids for stuff that doesn't render or doesn't work for SCLOrk here, it won't be added to the
// trie. Can copy directly from the comment in the SCLOrkEmoji.sc file if seen not rendering correctly
// there, then re-run the script. Please try and keep in alphabetical order by description.
var excludeIds = IdentitySet.newFrom([
]);
var docLines = File.readAllString("~/src/SCLOrkTools/scripts/emoji-test.txt".standardizePath).split($\n);
var uniTrie = MultiLevelIdentityDictionary.new;
var descMap = IdentityDictionary.new;
var idMap = IdentityDictionary.new;
var outFile;

docLines.do({ |line|
	// Ignore lines starting with comment indicator # and empty lines
	if (line.size > 0 and: { line[0] != $# }, {
		// Data line format is first some hexadecimal numbers, then a semi-colon followed by a
		// description of qualification, then a #, the space, the unicode character itself, and a
		// textual description. We want only fully-qualified unicode, for those we extract the
		// character and the text description.
		var match = line.findRegexp("([0-9A-F ]+); fully-qualified[ ]+ # (.*)");
		if (match.notNil and: { match.size == 3 }, {
			var id = match[1][1].replace($ ,"").asSymbol;
			if (excludeIds.findMatch(id).isNil, {
				var descBlock = match[2][1];
				var charSize = descBlock.find($ );
				var uniChar = descBlock[0..charSize-1].asSymbol;
				var description = descBlock[charSize+1..].toLower;
				// condition description
				description = description.replace("â€™", "'");
				description = description.replace(":", "");

				descMap.put(uniChar, description);
				idMap.put(uniChar, id);
				description.split($ ).do({ |word|
					var path = [];
					word.size.do({ |i|
						// Add counts for every letter in path.
						var count = uniTrie.at(*(path ++ [\count]));
						if (count.isNil, {
							count = 1;
						}, {
							count = count + 1;
						});
						uniTrie.put(*(path ++ [\count, count]));
						// Add letter to path as symbol.
						path = path.add(word[i].asSymbol);
					});
					// Add to match leaf array if not at root.
					if (path.size > 0, {
						var match = uniTrie.at(*(path ++ [\match]));
						if (match.isNil, {
							match = IdentitySet.new;
							uniTrie.put(*(path ++ [\match, match]));
						});
						match = match.add(uniChar);
					});
				});
			});
		});
	});
});


outFile = File.open("~/src/SCLOrkTools/classes/SCLOrkEmoji.sc".standardizePath, "w");
outFile.write("
// file generated by SCLOrkTools/scripts/build_emoji_trie.scd, make edits there and re-generate.
SCLOrkEmoji {
\tclassvar <trie;
\tclassvar <map;

\t*load {
\t\tif (trie.isNil, {
\t\t\tSCLOrkEmoji.prLoadTrie();
\t\t});
\t\tif (map.isNil, {
\t\t\tSCLOrkEmoji.prLoadMap();
\t\t});
\t}

\t*prLoadTrie {
\t\ttrie = MultiLevelIdentityDictionary.new;");

uniTrie.leafDo({ | keyPath, value |
	var line = "\n\t\ttrie.put(" ++ keyPath.collect({ |x|
		"'" ++ x.asString.escapeChar($') ++ "'"
	}).join(",");
	if (value.class === IdentitySet, {
		// Append # to make for a literal array instead of a set.
		line = line ++ ", #[\n";
		value.do({ |uni|
			line = line ++ "\t\t\t'%',\t// '%', // %\n".format(uni, idMap.at(uni).asString,
				descMap.at(uni));
		});
		line = line ++ "\t\t]);";
	}, {
		line = line ++ ", %);".format(value);
	});
	outFile.write(line);
});


outFile.write("
\t}

\t*prLoadMap {
\t\tmap = IdentityDictionary.new;
");

descMap.keysValuesDo({ |uni, desc|
	var line = "\n\t\tmap.put('%', \"%\");".format(uni.asString, desc);
	outFile.write(line);
});


outFile.write("
\t}
}
");

outFile.close;
^nil
)
